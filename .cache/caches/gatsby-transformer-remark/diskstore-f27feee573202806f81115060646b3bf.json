{"expireTime":9007200833963766000,"key":"transformer-remark-markdown-html-8254b421a5ada85a5d1308d100fc1275-gatsby-remark-relative-imagesgatsby-remark-imagesgatsby-remark-lazy-loadgatsby-remark-prismjs-","val":"<p>Em algum momento da sua vida, já ouviu falar sobre o quebra-cabeça, mas se por\nacaso não sabe o que é, tome cuidado nas suas pesquisas, existe um grande risco\nem se tornar um viciado (assim como eu). Aqui, vamos analisar e discutir\nmaneiras que podemos resolve-lo, obviamente utilizaremos o auxilio da\ntecnologia.</p>\n<p>Nosso problema consiste em uma grid 9 x 9, o principal objetivo é preencher as\nlinhas, as colunas e os sub quadrados 3 x 3 com números não repetidos de 1 a 9\nda nossa matriz.</p>\n<div style=\"text-align: center\">\n![](https://cdn-images-1.medium.com/max/800/1*lTLwAvQ0i1s1mdhmxjcjng.png)\n</div>\n<span class=\"figcaption_hack\">Sudoku</span>\n<h3>Resolvendo o problema</h3>\n<p>Esse é um problema como qualquer outro, primeiramente devemos analisar o que ele\nvai impactar e qual a melhor forma de resolve-lo. Minha primeira solução, você\npoderia escrever um <strong>algoritmo com backtracking</strong>. Basicamente teríamos que\npercorrer nossa matriz e dessa forma dizer se um determinado número é possível\nem determinada posição.</p>\n<h3>Backtracking</h3>\n<p>Um algoritmo de força bruta visita todas as células vazias, preenchendo os\nnúmeros quando foram válidos. Caso o algoritmo encontre alguma inconformidade,\nele pode descartar todos os casos testados anteriormente.</p>\n<p>A animação facilita nosso entendimento:</p>\n<div style=\"text-align: center\">\n![](https://cdn-images-1.medium.com/max/800/1*ISlzB1fMXIYeovi3OrmyYw.gif)\n</div>\n<span class=\"figcaption_hack\">Sudoku sendo preenchido</span>\n<p><strong>As vantagens</strong></p>\n<ul>\n<li>Uma solução é garantida</li>\n<li>Esse algoritmo não é tão complexo, quanto os outros que fazem o mesmo</li>\n</ul>\n<p><strong>A desvantagem</strong></p>\n<ul>\n<li>O tempo de resolução pode ser relativamente lento, estatisticamente esse\nalgoritmo pode requerer 15 000 à 90 000 ciclos, sendo cada ciclo uma mudança na\nposição de um ponteiro, conforme move-se entre as células.</li>\n</ul>\n<h3>Afinal, backtracking é IA?</h3>\n<p>O conceito de inteligência artificial é muito amplo, e pode ser definido de\nvárias formas. Mas podemos pensar em algumas características básicas, tais como,\n<strong>capacidade de raciocínio</strong> (aplicar regras lógicas para chegar a uma\nconclusão) e <strong>aprendizagem</strong> (aprender com os erros e acertos, para que no\nfuturo consiga executar de forma mais eficaz).</p>\n<p>Os famosos algoritmos de procura que conhecemos hoje (aqui entra a técnica de\n<strong>backtracking</strong>), no inicio, um programa inteligente tentaria por força bruta\nencontrar uma solução através de todas as possibilidades possíveis. </p>\n<h3>Repensando a nossa solução</h3>\n<p>Podemos utilizar outra forma para resolver nosso problema, aliás, existem várias\noutras, mas vamos focar em apenas outra. Começamos analisando onde temos menos\npossibilidades para colocar um único número.</p>\n<div style=\"text-align: center\">\n![](https://cdn-images-1.medium.com/max/800/1*Vv7ulMFh_D8VrrZx_PyJjg.png)\n</div>\n<span class=\"figcaption_hack\">Gerando novas matrizes</span>\n<p>No exemplo acima, escolhemos uma célula que possui duas possibilidades, dessa\nforma temos uma nova matriz com os valores 8 e 9, da qual podemos aplicar a\n<strong>propagação de restrição</strong> (pode ser usada para reduzir o espaço de pesquisa e\ntornar o problema mais fácil para ser resolvido). Aqui temos o famoso caso de\n<strong>recursividade</strong>.</p>\n<h3>Programação recursiva</h3>\n<p>Indo direto ao ponto, um programa recursivo tenta resolver algo chamando a si\npróprio. O grande detalhe é que na segunda chamada seu valor foi influenciado\npelo valor original, assim, resolvendo problema menores e no final lhe\nentregando uma única solução. Não é algo tão simples em entender, talvez com um\nexemplo vai facilitar.</p>\n<p>Exemplo em Python:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def sumR (n):\n    if n == 1:\n        return 1\n    else:\n        return n + sumR(n-1)</code></pre></div>\n<p>Esta forma acima garante a solução de qualquer sudoku. </p>\n<h3>Algoritmos gulosos</h3>\n<p>Em cada iteração que esse algoritmo faz, ele escolhe qual a opção mais\n“apetitosa” que vê pela frente. Ele toma decisões com base nas informações\ndisponíveis na própria iteração. O algoritmo guloso jamais volta atras, as suas\n<strong>escolhas são definitivas</strong>. Apesar do pouco uso dessa solução, pode se dizer\nque são muito <strong>rápidos e eficientes</strong>.</p>\n<p>Alguns problemas que podem ser resolvidos com algoritmos gulosos:</p>\n<ul>\n<li><a href=\"https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/mochila-frac.html\">Mochila\nfracionária</a></li>\n<li><a href=\"https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/intervalos.html\">Escalonamento de\nintervalos</a></li>\n<li><a href=\"https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/huffman.html\">Árvore de\nHuffman</a></li>\n</ul>\n<h3>Programação dinâmica</h3>\n<p>Essa técnica consiste em dividir o problema geral em subproblemas mais simples e\nir resolvendo-os de forma iterativa, armazenando os resultados em uma tabela\npara serem usados quando quiser. Sendo mais especifico, a ideia é <strong>construir\npor etapas uma resposta já obtidas por partes menores</strong>. </p>\n<p>Alguns algoritmos que usam programação dinâmica:</p>\n<ul>\n<li><a href=\"https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/sscm.html#dynprog2\">Subsequência crescente\nmáxima</a></li>\n<li><a href=\"https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/sscm.html#LCS\">Subsequência comum\nmáxima</a></li>\n<li><a href=\"https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/mochila-subsetsum.html#dynamic-programming\">Problema\nsubset-sum</a></li>\n<li><a href=\"https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/mochila-bool.html#prog-din\">Problema da mochila\nbooleana</a></li>\n<li><a href=\"https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/dijkstra.html\">Dijkstra</a></li>\n</ul>\n<h3><strong>As diferenças entre algoritmo guloso e programação dinâmica</strong></h3>\n<p>Muitas vezes é difícil diferenciar esses algoritmos, mas eles possuem algumas\n<strong>características especificas</strong>:</p>\n<p>Guloso:</p>\n<ul>\n<li>Pega a alternativa mais promissora;</li>\n<li>É muito rápido;</li>\n<li>Uma decisão tomada é definitiva.</li>\n</ul>\n<p>PD:</p>\n<ul>\n<li>Explora todas as alternativas de maneira eficiente;</li>\n<li>Um pouco lento;</li>\n<li>A cada iteração pode se arrepender de decisões tomadas.</li>\n</ul>\n<p>Além desses algoritmos citados, existem vários outros. Alguns mais complexos,\noutros nem tanto. Espero que tenha gostado :D</p>\n<p><strong>Agradecimento</strong>: <em>Esse texto foi revisado por</em> <a href=\"https://www.facebook.com/allan.sene\">Allan\nSene</a></p>\n<p>Referências:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Sudoku_solving_algorithms\">https://en.wikipedia.org/wiki/Sudoku<em>solving</em>algorithms</a></li>\n<li><a href=\"https://norvig.com/sudoku.html\">https://norvig.com/sudoku.html</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Local_consistency\">https://en.wikipedia.org/wiki/Local_consistency</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Backtracking\">https://en.wikipedia.org/wiki/Backtracking</a></li>\n<li><a href=\"https://jeffe.cs.illinois.edu/teaching/algorithms/notes/03-backtracking.pdf\">https://jeffe.cs.illinois.edu/teaching/algorithms/notes/03-backtracking.pdf</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Constraint_satisfaction\">https://en.wikipedia.org/wiki/Constraint_satisfaction</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Search_algorithm\">https://en.wikipedia.org/wiki/Search_algorithm</a></li>\n<li><a href=\"https://medium.com/@pmprakhargenius/sudoku-solver-ai-agent-700897b936c7\">https://medium.com/@pmprakhargenius/sudoku-solver-ai-agent-700897b936c7</a></li>\n<li><a href=\"https://dev.to/willamesoares/what-i-learned-from-implementing-a-sudoku-solver-in-python-3a3g\">https://dev.to/willamesoares/what-i-learned-from-implementing-a-sudoku-solver-in-python-3a3g</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Constraint_satisfaction\">https://en.wikipedia.org/wiki/Constraint_satisfaction</a></li>\n<li><a href=\"https://wiki.icmc.usp.br/images/c/cb/SCC211Cap11.pdf\">https://wiki.icmc.usp.br/images/c/cb/SCC211Cap11.pdf</a></li>\n<li><a href=\"https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/dynamic-programming.html\">https://www.ime.usp.br/~pf/analise<em>de</em>algoritmos/aulas/dynamic-programming.html</a></li>\n<li><a href=\"https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/guloso.html\">https://www.ime.usp.br/~pf/analise<em>de</em>algoritmos/aulas/guloso.html</a></li>\n</ul>"}